"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextTriangulation = TextTriangulation;
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Core = require("@antv/l7-core");

var _l7Utils = require("@antv/l7-utils");

var _lodash = require("lodash");

var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));

var _collisionIndex = _interopRequireDefault(require("../../utils/collision-index"));

var _symbolLayout = require("../../utils/symbol-layout");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/* babel-plugin-inline-import '../shaders/tile/text_frag.glsl' */
var text_frag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n// uniform float u_font_size : 24.0;\nuniform float u_opacity : 1.0;\nuniform vec4 u_stroke_color : [0, 0, 0, 1];\nuniform float u_stroke_width : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\n#pragma include \"picking\"\nvoid main() {\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  lowp float buff = (6.0 - u_stroke_width / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  \n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), vec4(u_stroke_color.rgb, u_stroke_color.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";

/* babel-plugin-inline-import '../shaders/tile/text_vert.glsl' */
var text_vert = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\nvarying float v_fontScale;\n\nuniform float u_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = a_Size / FONT_SIZE;\n  v_fontScale = fontScale;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  vec4 projected_position;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n   projected_position  = u_Mvp * (vec4(a_Position.xyz, 1.0));\n  } else { // else\n   projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  gl_Position = vec4(\n    projected_position.xy / projected_position.w + a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n";

/* babel-plugin-inline-import '../shaders/tile/text_map_frag.glsl' */
var text_map_frag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n\nuniform float u_opacity : 1.0;\nuniform vec4 u_stroke_color : [0, 0, 0, 1];\nuniform float u_stroke_width : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\nuniform vec4 u_color;\n\nvoid main() {\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  lowp float buff = (6.0 - u_stroke_width / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  \n  gl_FragColor = mix(vec4(u_color.rgb, u_color.a * u_opacity), vec4(u_stroke_color.rgb, u_stroke_color.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n}\n";

/* babel-plugin-inline-import '../shaders/tile/text_map_vert.glsl' */
var text_map_vert = "#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nuniform float u_size;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = u_size / FONT_SIZE;\n  v_fontScale = fontScale;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  vec4 projected_position;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n   projected_position  = u_Mvp * (vec4(a_Position.xyz, 1.0));\n  } else { // else\n   projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n\n  gl_Position = vec4(\n    projected_position.xy / projected_position.w + a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n\n}\n";

function TextTriangulation(feature) {
  // @ts-ignore
  var that = this;
  var id = feature.id;
  var vertices = [];
  var indices = [];

  if (!that.glyphInfoMap || !that.glyphInfoMap[id]) {
    return {
      vertices: [],
      // [ x, y, z, tex.x,tex.y, offset.x. offset.y]
      indices: [],
      size: 7
    };
  }

  var centroid = that.glyphInfoMap[id].centroid; // 计算中心点

  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  that.glyphInfoMap[id].glyphQuads.forEach(function (quad, index) {
    vertices.push.apply(vertices, (0, _toConsumableArray2.default)(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));
    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);
  });
  return {
    vertices: vertices,
    // [ x, y, z, tex.x,tex.y, offset.x. offset.y]
    indices: indices,
    size: 7
  };
}

var TextModel = /*#__PURE__*/function (_BaseModel) {
  (0, _inherits2.default)(TextModel, _BaseModel);

  var _super = _createSuper(TextModel);

  function TextModel() {
    var _this;

    (0, _classCallCheck2.default)(this, TextModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "glyphInfoMap", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "currentZoom", -1);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "textureHeight", 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "textCount", 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "preTextStyle", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "mapping", function () {
      _this.initGlyph();

      _this.updateTexture();

      _this.filterGlyphs();

      _this.reBuildModel();
    });
    return _this;
  }

  (0, _createClass2.default)(TextModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1.0 : _ref$opacity,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 0 : _ref$strokeWidth,
          _ref$textAnchor = _ref.textAnchor,
          textAnchor = _ref$textAnchor === void 0 ? 'center' : _ref$textAnchor,
          _ref$textAllowOverlap = _ref.textAllowOverlap,
          textAllowOverlap = _ref$textAllowOverlap === void 0 ? false : _ref$textAllowOverlap,
          _ref$halo = _ref.halo,
          halo = _ref$halo === void 0 ? 0.5 : _ref$halo,
          _ref$gamma = _ref.gamma,
          gamma = _ref$gamma === void 0 ? 2.0 : _ref$gamma,
          usage = _ref.usage,
          _ref$color = _ref.color,
          color = _ref$color === void 0 ? '#fff' : _ref$color,
          _ref$size = _ref.size,
          size = _ref$size === void 0 ? 1 : _ref$size;

      var _this$fontService = this.fontService,
          canvas = _this$fontService.canvas,
          mapping = _this$fontService.mapping;

      if (Object.keys(mapping).length !== this.textCount) {
        this.updateTexture();
        this.textCount = Object.keys(mapping).length;
      }

      this.preTextStyle = {
        textAnchor: textAnchor,
        textAllowOverlap: textAllowOverlap
      };
      return {
        u_opacity: (0, _lodash.isNumber)(opacity) ? opacity : 1.0,
        u_stroke_width: (0, _lodash.isNumber)(strokeWidth) ? strokeWidth : 1.0,
        u_stroke_color: this.getStrokeColor(stroke),
        u_sdf_map: this.texture,
        u_halo_blur: halo,
        u_gamma_scale: gamma,
        u_sdf_map_size: [canvas.width, canvas.height],
        u_color: usage === 'basemap' ? (0, _l7Utils.rgb2arr)(color) : [0, 0, 0, 0],
        u_size: usage === 'basemap' ? size : 1
      };
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _ref2, _ref2$textAnchor, textAnchor, _ref2$textAllowOverla, textAllowOverlap;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.extent = this.textExtent();
                _ref2 = this.layer.getLayerConfig(), _ref2$textAnchor = _ref2.textAnchor, textAnchor = _ref2$textAnchor === void 0 ? 'center' : _ref2$textAnchor, _ref2$textAllowOverla = _ref2.textAllowOverlap, textAllowOverlap = _ref2$textAllowOverla === void 0 ? true : _ref2$textAllowOverla;
                this.preTextStyle = {
                  textAnchor: textAnchor,
                  textAllowOverlap: textAllowOverlap
                };
                _context.next = 5;
                return this.buildModels();

              case 5:
                return _context.abrupt("return", _context.sent);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initModels() {
        return _initModels.apply(this, arguments);
      }

      return initModels;
    }()
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _this$layer$getLayerC, usage, model;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.mapping();
                _this$layer$getLayerC = this.layer.getLayerConfig(), usage = _this$layer$getLayerC.usage;
                _context2.next = 4;
                return this.layer.buildLayerModel({
                  moduleName: 'pointTileText_' + usage,
                  vertexShader: usage === 'basemap' ? text_map_vert : text_vert,
                  fragmentShader: usage === 'basemap' ? text_map_frag : text_frag,
                  triangulation: TextTriangulation.bind(this),
                  depth: {
                    enable: false
                  },
                  blend: this.getBlend(),
                  pick: usage !== 'basemap'
                });

              case 4:
                model = _context2.sent;
                return _context2.abrupt("return", [model]);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function buildModels() {
        return _buildModels.apply(this, arguments);
      }

      return buildModels;
    }()
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this$layer$getLayerC2 = this.layer.getLayerConfig(),
          usage = _this$layer$getLayerC2.usage;

      this.styleAttributeService.registerStyleAttribute({
        name: 'textOffsets',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_textOffsets',
          buffer: {
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[5], vertex[6]];
          }
        }
      });

      if (usage !== 'basemap') {
        this.styleAttributeService.registerStyleAttribute({
          name: 'size',
          type: _l7Core.AttributeType.Attribute,
          descriptor: {
            name: 'a_Size',
            buffer: {
              usage: _l7Core.gl.DYNAMIC_DRAW,
              data: [],
              type: _l7Core.gl.FLOAT
            },
            size: 1,
            update: function update(feature) {
              var _feature$size = feature.size,
                  size = _feature$size === void 0 ? 12 : _feature$size;
              return Array.isArray(size) ? [size[0]] : [size];
            }
          }
        });
      }

      this.styleAttributeService.registerStyleAttribute({
        name: 'textUv',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_tex',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "textExtent",
    value: function textExtent() {
      var bounds = this.mapService.getBounds();
      return (0, _l7Utils.padBounds)(bounds, 0.5);
    }
    /**
     * 生成文字纹理（生成文字纹理字典）
     */

  }, {
    key: "initTextFont",
    value: function initTextFont() {
      var _ref3 = this.layer.getLayerConfig(),
          _ref3$fontWeight = _ref3.fontWeight,
          fontWeight = _ref3$fontWeight === void 0 ? '400' : _ref3$fontWeight,
          _ref3$fontFamily = _ref3.fontFamily,
          fontFamily = _ref3$fontFamily === void 0 ? 'sans-serif' : _ref3$fontFamily;

      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
            shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();

        var _iterator = _createForOfIteratorHelper(shape),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var char = _step.value;

            // 去重
            if (characterSet.indexOf(char) === -1) {
              characterSet.push(char);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        iconfont: false
      });
    }
    /**
     * 生成文字布局（对照文字纹理字典提取对应文字的位置很好信息）
     */

  }, {
    key: "generateGlyphLayout",
    value: function generateGlyphLayout() {
      var _this2 = this;

      var mapping = this.fontService.mapping;

      var _ref4 = this.layer.getLayerConfig(),
          _ref4$spacing = _ref4.spacing,
          spacing = _ref4$spacing === void 0 ? 2 : _ref4$spacing,
          _ref4$textAnchor = _ref4.textAnchor,
          textAnchor = _ref4$textAnchor === void 0 ? 'center' : _ref4$textAnchor;

      var data = this.layer.getEncodedData();
      this.glyphInfo = data.map(function (feature) {
        var _feature$shape = feature.shape,
            shape = _feature$shape === void 0 ? '' : _feature$shape,
            id = feature.id,
            _feature$size2 = feature.size,
            size = _feature$size2 === void 0 ? 1 : _feature$size2,
            _feature$textOffset = feature.textOffset,
            textOffset = _feature$textOffset === void 0 ? [0, 0] : _feature$textOffset;
        var shaping = (0, _symbolLayout.shapeText)(shape.toString(), mapping, // @ts-ignore
        size, textAnchor, 'left', spacing, textOffset, false);
        var glyphQuads = (0, _symbolLayout.getGlyphQuads)(shaping, textOffset, false);
        feature.shaping = shaping;
        feature.glyphQuads = glyphQuads;
        feature.centroid = (0, _l7Utils.calculateCentroid)(feature.coordinates); // 此时地图高德2.0 originCentroid == centroid

        feature.originCentroid = feature.version === 'GAODE2.x' ? (0, _l7Utils.calculateCentroid)(feature.originCoordinates) : feature.originCentroid = feature.centroid;
        _this2.glyphInfoMap[id] = {
          shaping: shaping,
          glyphQuads: glyphQuads,
          centroid: (0, _l7Utils.calculateCentroid)(feature.coordinates)
        };
        return feature;
      });
    }
    /**
     * 文字避让 depend on originCentorid
     */

  }, {
    key: "filterGlyphs",
    value: function filterGlyphs() {
      var _this3 = this;

      var _ref5 = this.layer.getLayerConfig(),
          _ref5$padding = _ref5.padding,
          padding = _ref5$padding === void 0 ? [4, 4] : _ref5$padding,
          _ref5$textAllowOverla = _ref5.textAllowOverlap,
          textAllowOverlap = _ref5$textAllowOverla === void 0 ? false : _ref5$textAllowOverla;

      if (textAllowOverlap) {
        // 如果允许文本覆盖
        return;
      }

      this.glyphInfoMap = {};
      this.currentZoom = this.mapService.getZoom();
      this.extent = this.textExtent();

      var _this$rendererService = this.rendererService.getViewportSize(),
          width = _this$rendererService.width,
          height = _this$rendererService.height;

      var collisionIndex = new _collisionIndex.default(width, height);
      var filterData = this.glyphInfo.filter(function (feature) {
        var shaping = feature.shaping,
            _feature$id = feature.id,
            id = _feature$id === void 0 ? 0 : _feature$id;
        var centroid = feature.version === 'GAODE2.x' ? feature.originCentroid : feature.centroid;
        var size = feature.size;
        var fontScale = size / 24;

        var pixels = _this3.mapService.lngLatToContainer(centroid);

        var _collisionIndex$place = collisionIndex.placeCollisionBox({
          x1: shaping.left * fontScale - padding[0],
          x2: shaping.right * fontScale + padding[0],
          y1: shaping.top * fontScale - padding[1],
          y2: shaping.bottom * fontScale + padding[1],
          anchorPointX: pixels.x,
          anchorPointY: pixels.y
        }),
            box = _collisionIndex$place.box;

        if (box && box.length) {
          collisionIndex.insertCollisionBox(box, id);
          return true;
        } else {
          return false;
        }
      });
      filterData.forEach(function (item) {
        // @ts-ignore
        _this3.glyphInfoMap[item.id] = item;
      });
    }
    /**
     * 初始化文字布局
     */

  }, {
    key: "initGlyph",
    value: function initGlyph() {
      // 1.生成文字纹理
      this.initTextFont(); // 2.生成文字布局

      this.generateGlyphLayout();
    }
    /**
     * 更新文字纹理
     */

  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.fontService.canvas;
      this.textureHeight = canvas.height;

      if (this.texture) {
        this.texture.destroy();
      }

      this.texture = createTexture2D({
        data: canvas,
        mag: _l7Core.gl.LINEAR,
        min: _l7Core.gl.LINEAR,
        width: canvas.width,
        height: canvas.height
      });
    }
  }, {
    key: "reBuildModel",
    value: function () {
      var _reBuildModel = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var _this$layer$getLayerC3, usage, model;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _this$layer$getLayerC3 = this.layer.getLayerConfig(), usage = _this$layer$getLayerC3.usage;
                this.filterGlyphs();
                _context3.next = 4;
                return this.layer.buildLayerModel({
                  moduleName: 'pointTileText_' + usage,
                  vertexShader: usage === 'basemap' ? text_map_vert : text_vert,
                  fragmentShader: usage === 'basemap' ? text_map_frag : text_frag,
                  triangulation: TextTriangulation.bind(this),
                  depth: {
                    enable: false
                  },
                  blend: this.getBlend(),
                  pick: usage !== 'basemap'
                });

              case 4:
                model = _context3.sent;
                return _context3.abrupt("return", [model]);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function reBuildModel() {
        return _reBuildModel.apply(this, arguments);
      }

      return reBuildModel;
    }()
  }]);
  return TextModel;
}(_BaseModel2.default);

exports.default = TextModel;